// *********************************************************
// *                                                       *
// *   Copyright (C) Microsoft. All rights reserved.       *
// *                                                       *
// *********************************************************

//----------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Input Grammar      : Sarif
//     Input Grammar file : D:\GitHub\sarif-sdk\src\Sarif\GrammarFiles\Sarif.g4
//     
//     Changes to this file may cause incorrect behavior and 
//     will be lost when the code is regenerated.
// </auto-generated>
//----------------------------------------------------------

using Nest;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;

namespace NuGet.Search.Common.ElasticSearch.NuGet
{
    /// <summary>An enumeration containing all the types which implement <see cref="ISyntax" />.</summary>
    public enum SarifKind
    {
        /// <summary>An uninitialized kind.</summary>
        None,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type AnnotatedCodeLocation.</summary>
        AnnotatedCodeLocation,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FileChange.</summary>
        FileChange,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FileReference.</summary>
        FileReference,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Fix.</summary>
        Fix,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type FormattedMessage.</summary>
        FormattedMessage,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Hash.</summary>
        Hash,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Location.</summary>
        Location,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type LogicalLocationComponent.</summary>
        LogicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type PhysicalLocationComponent.</summary>
        PhysicalLocationComponent,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Region.</summary>
        Region,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Replacement.</summary>
        Replacement,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type Result.</summary>
        Result,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ResultLog.</summary>
        ResultLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RuleDescriptor.</summary>
        RuleDescriptor,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunInfo.</summary>
        RunInfo,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type RunLog.</summary>
        RunLog,

        /// <summary>An entry indicating that the <see cref="ISyntax" /> object is of type ToolInfo.</summary>
        ToolInfo,
    }

    /// <summary>
    /// A code annotation that consists of single physical location and associated message, used to express
    /// stacks, execution flow through a method, or other locations that are related to a result.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class AnnotatedCodeLocation
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.AnnotatedCodeLocation.ToString(); } }

        /// <summary>
        /// A code location to which this annotation refers.
        /// </summary>
        [DataMember(Name = "physicalLocation", IsRequired = true)]
        public IList<PhysicalLocationComponent> PhysicalLocation { get; set; }

        /// <summary>
        /// A message associated with this annotation, if applicable.
        /// </summary>
        [DataMember(Name = "message", IsRequired = false, EmitDefaultValue = false)]
        public string Message { get; set; }
    }

    /// <summary>
    /// A change to a single file.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FileChange
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.FileChange.ToString(); } }

        /// <summary>
        /// A string that represents the location of the file to change as a valid URI.
        /// </summary>
        [DataMember(Name = "uri", IsRequired = true)]
        public string Uri { get; set; }

        /// <summary>
        /// An array of replacement objects, each of which represents the replacement of a single range of
        /// bytes in a single file specified by the uri property.
        /// </summary>
        [DataMember(Name = "replacements", IsRequired = true)]
        public IList<Replacement> Replacements { get; set; }
    }

    /// <summary>
    /// A fileReference object represents a single file
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FileReference
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.FileReference.ToString(); } }

        /// <summary>
        /// The location of the file as a valid URI
        /// </summary>
        [DataMember(Name = "uri", IsRequired = true)]
        public string Uri { get; set; }

        /// <summary>
        /// An optional array of hash objects, each of which specifies a hashed value for the file specified
        /// by the uri property, along with the name of the algorithm used to compute the hash.
        /// </summary>
        [DataMember(Name = "hashes", IsRequired = false, EmitDefaultValue = false)]
        public IList<Hash> Hashes { get; set; }
    }

    /// <summary>
    /// A proposed fix an a code defect represented by a result object. A fix specifies a set of file to modify.
    /// For each file, the fix specifies a set of bytes to remove and provides a set of new bytes to replace them.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Fix
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Fix.ToString(); } }

        /// <summary>
        /// A string that describes the proposed fix, enabling viewers to present a proposed change to an end user.
        /// </summary>
        [DataMember(Name = "description", IsRequired = true)]
        public string Description { get; set; }

        /// <summary>
        /// A message associated with this annotation, if applicable.
        /// </summary>
        [DataMember(Name = "fileChanges", IsRequired = true)]
        public IList<FileChange> FileChanges { get; set; }
    }

    /// <summary>
    /// A formatted message object encapsulates information that can be used to construct a
    /// fully formatted message that describes an issue.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class FormattedMessage
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.FormattedMessage.ToString(); } }

        /// <summary>
        /// A string that identifies the format string used to format the message that describes
        /// this result. The value of specifierId must correspond to one of the names in the set
        /// of name/value pairs contained in the format specifiers property of the rule info
        /// object whose id property matches the rule id property of this issue.
        /// </summary>
        [DataMember(Name = "specifierId", IsRequired = true)]
        public string SpecifierId { get; set; }

        /// <summary>
        /// An array of string values that will be used, in combination with a format specifier,
        /// to construct a result message.
        /// </summary>
        [DataMember(Name = "arguments", IsRequired = true)]
        public IList<string> Arguments { get; set; }
    }

    /// <summary>
    /// A hash value of some file or collection of files, together with the algorithm used to compute the hash.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Hash
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Hash.ToString(); } }

        /// <summary>
        /// The hash value of some file or collection of files, computed by the algorithm named in the algorithm property.
        /// </summary>
        [DataMember(Name = "value", IsRequired = true)]
        public string Value { get; set; }

        /// <summary>
        /// A string specifying the name of the algorithm used to compute the hash value specified in the value property.
        /// This shall be one of the following: BLAKE-256, BLAKE-512, ECOH, FSB, GOST, Groestl, HAS-160, HAVAL, JH, MD2,
        /// MD4, MD5, MD6, RadioGatun, RIPEMD, RIPEMD-128, RIPEMD-160, RIPEMD-320, SHA-1, SHA-224, SHA-256, SHA-384,
        /// SHA-512, SHA-3, Skein, Snefru, Spectral Hash, SWIFFT, Tiger, Whirlpool.
        /// </summary>
        [DataMember(Name = "algorithm", IsRequired = true)]
        public string Algorithm { get; set; }

    }

    /// <summary>
    /// Specifies a location within a file, or within an object nested within a file
    /// (such as a location within an assembly contained in an appx file).
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class Location
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Location.ToString(); } }

        /// <summary>
        /// A source file that is associated with the item that the static analysis tool scanned. This
        /// may be a .dll in the case of a binary analysis tool like FxCop, or a C++ file in the case
        /// of a source analysis tool like PREfast. Note that the defect may not actually occur in this file.
        /// </summary>
        [DataMember(Name = "analysisTarget", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> AnalysisTarget { get; set; }

        /// <summary>
        /// A source file that is associated with the current result if and only if that is not the
        /// same as the analysis target. This member will populated or not, in many cases, depending
        /// on whether PDBs associated with the analysis target are available. Examples include a C# file
        /// in the FxCop-like binary analysis case, or possibly a .H C++ file in the case of a source
        /// analysis tool like PREfast.
        /// </summary>
        [DataMember(Name = "resultFile", IsRequired = false, EmitDefaultValue = false)]
        public IList<PhysicalLocationComponent> ResultFile { get; set; }

        /// <summary>
        /// An object that specifies the logical location for which a result is produced.
        /// </summary>
        [DataMember(Name = "logicalLocation", IsRequired = false, EmitDefaultValue = false)]
        public IList<LogicalLocationComponent> LogicalLocation { get; set; }

        /// <summary>
        /// A string containing the language-specific logical name of the location where the result occurs; e.g.
        ///     C: Foo
        ///     C++: Namespace::Class::MemberFunction(int, double) const&amp;&amp;
        ///     C++: Namespace::NonmemberFunction(int, double)
        ///     C#: SecurityCryptographyRuleTests.DESCannotBeUsed.EncryptData(System.String,System.String,System.Byte[],System.Byte[])
        /// </summary>
        [DataMember(Name = "fullyQualifiedLogicalName", IsRequired = false, EmitDefaultValue = false)]
        public string FullyQualifiedLogicalName { get; set; }

        /// <summary>
        /// Key/value pairs that provide additional information about this location.
        /// This might be used to annotate specific stack frames or points in code
        /// with additional information, such as assumed values of variables at that
        /// point of execution, etc.
        /// </summary>
        [DataMember(Name = "properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }
    }

    /// <summary>
    /// One level (e.g. namespace, function, etc.) of a logical location tree.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class LogicalLocationComponent
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.LogicalLocationComponent.ToString(); } }

        /// <summary>
        /// Name of the item specified by this location component.
        /// </summary>
        [DataMember(Name = "name", IsRequired = true)]
        public string Name { get; set; }

        /// <summary>
        /// The type of item this location refers to.
        /// </summary>
        [DataMember(Name = "kind", IsRequired = false, EmitDefaultValue = false)]
        public string Kind { get; set; }

    }

    /// <summary>
    /// A part of a location that refers to a file.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class PhysicalLocationComponent
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.PhysicalLocationComponent.ToString(); } }

        /// <summary>
        /// Uri to the file specified by this location.
        /// </summary>
        [DataMember(Name = "uri", IsRequired = true)]
        public string Uri { get; set; }

        /// <summary>
        /// The MIME content type (RFC 2045) of the item referred to by this location.
        /// </summary>
        [DataMember(Name = "mimeType", IsRequired = false, EmitDefaultValue = false)]
        public string MimeType { get; set; }

        /// <summary>
        /// The specific region within the analysis where the result was detected. This SHOULD only be
        /// set on the last physicalLocationComponent in a physicalLocation most of the time.
        /// (There are some exceptions e.g. an embedded .SWF in an Office 2003 format ppt)
        /// </summary>
        [DataMember(Name = "region", IsRequired = false, EmitDefaultValue = false)]
        public Region Region { get; set; }

    }

    /// <summary>
    /// Specifies a region within a file where a result was detected.
    /// </summary>
    /// <remarks>
    /// Minimally, the Region should be populated with the StartLine or Offset members.
    /// There is some duplication of information in Region members. Log file producers
    /// are responsible for ensuring that any members populated in this type are
    /// consistent with each other (e.g., the file offset, if provided, should match the
    /// StartLine + EndColumn, if also provided). In the event that the type members are
    /// fully populated, viewers are free to choose whatever data is easiest to consume.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Region
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Region.ToString(); } }

        /// <summary>
        /// The starting line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name = "startLine", IsRequired = false, EmitDefaultValue = false)]
        public int StartLine { get; set; }

        /// <summary>
        /// The starting column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name = "startColumn", IsRequired = false, EmitDefaultValue = false)]
        public int StartColumn { get; set; }

        /// <summary>
        /// The ending line location associated with a region in the text file.
        /// </summary>
        [DataMember(Name = "endLine", IsRequired = false, EmitDefaultValue = false)]
        public int EndLine { get; set; }

        /// <summary>
        /// The ending column location associated with a region in the text file.
        /// </summary>
        [DataMember(Name = "endColumn", IsRequired = false, EmitDefaultValue = false)]
        public int EndColumn { get; set; }

        /// <summary>
        /// The zero-based offset (measured in characters) of the first character in the region from the beginning of the file.
        /// </summary>
        [DataMember(Name = "charOffset", IsRequired = false, EmitDefaultValue = false)]
        public int CharOffset { get; set; }

        /// <summary>
        /// The zero-based offset (measured in bytes) of the first byte in the region from the beginning of the file.
        /// </summary>
        [DataMember(Name = "byteOffset", IsRequired = false, EmitDefaultValue = false)]
        public int ByteOffset { get; set; }

        /// <summary>
        /// The length of the region.
        /// </summary>
        [DataMember(Name = "length", IsRequired = false, EmitDefaultValue = false)]
        public int Length { get; set; }

    }

    /// <summary>
    /// The replacement of a single range of bytes in a file. Each instance specifies the location within
    /// the file where the replacement is to be made, the number of bytes to remove at that location, and
    /// a sequence of bytes to insert at that location.
    /// </summary>
    /// <remarks>
    /// If a replacement object specifies both the removal of a byte range by means of the deletedLength
    /// property and the insertion of a sequence of bytes by means of the insertedBytes property, then
    /// the effect of the replacment shall be as if the removal were performed before the insertion.
    /// If a single fileChange object specifies more than one replacement, then the effect of the
    /// replacements shall be as if they were performed in the order in which they appear in the
    /// replacements array. The offset property of each replacement shall specify an offset in the
    /// unmodified file (i.e., the offsets are not recomputed based on any prior changes to the file).
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    public sealed class Replacement
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Replacement.ToString(); } }

        /// <summary>
        /// A non-negative integer specifying the offset in bytes from the beginning of the file at
        /// which bytes are to be removed, inserted or both. An offset of 0 shall denote the first
        /// byte in the file.
        /// </summary>
        [DataMember(Name = "offset", IsRequired = true)]
        public int Offset { get; set; }

        /// <summary>
        /// An optional integer specifying the number of bytes to delete, start at the
        /// byte offset specified by the offset property, measured from the beginning of the file.
        /// </summary>
        [DataMember(Name = "deletedLength", IsRequired = true)]
        public int DeletedLength { get; set; }

        /// <summary>
        /// An optional string that specifies the byte sequence to be inserted at the byte offset
        /// specified by the offset property, measured from the beginning of the file.
        /// </summary>
        [DataMember(Name = "insertedBytes", IsRequired = true)]
        public int InsertedBytes { get; set; }

    }

    /// <summary>
    /// Represents one or more observations about an analysis target produced by a static analysis tool.
    /// </summary>
    /// <remarks>
    /// A result frequently, but not always, represents a code defect.
    /// </remarks>
    [DataContract]
    [CompilerGenerated]
    [ElasticType]
    public sealed class Result
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.Result.ToString(); } }

        /// <summary>
        /// An opaque, stable identifier that uniquely identifies the specific rule associated with
        /// the result (e.g., CA2001).
        /// </summary>
        [DataMember(Name = "ruleId", IsRequired = true)]
        public string RuleId { get; set; }

        /// <summary>
        /// A string specifying the kind of observation this result represents.
        /// This shall be one of the following: warning, error, pass, pending, note, notApplicable, internalError.
        /// If this member is not present, its implied value is 'warning'.
        /// </summary>
        [DataMember(Name = "kind", IsRequired = false, EmitDefaultValue = false)]
        public string Kind { get; set; }

        /// <summary>
        /// A string that comprehensively describes the result to the users.
        /// </summary>
        [DataMember(Name = "fullMessage", IsRequired = false, EmitDefaultValue = false)]
        public string FullMessage { get; set; }

        /// <summary>
        /// A short description that summarizes an issue to the user in one or two lines.
        /// </summary>
        [DataMember(Name = "shortMessage", IsRequired = false, EmitDefaultValue = false)]
        public string ShortMessage { get; set; }

        /// <summary>
        /// A formattedMessage object that can be used to construct a fully formatted message that describes the result.
        /// If the formatted message property is present on an result, the full message property shall not be present.
        /// If the full message property is present on an result, the formatted message property shall not be present
        /// </summary>
        [DataMember(Name = "formattedMessage", IsRequired = false, EmitDefaultValue = false)]
        public FormattedMessage FormattedMessage { get; set; }

        /// <summary>
        /// Specifies one or more peer locations where an issue is located. Note that this is not used
        /// to point to multiple instances of the same issue; separate instances should have separate
        /// issue objects. For example, a misspelled partial class in C# may list all the source
        /// lines on which the partial class is declared as separate top-level locations. However, two
        /// independent misspellings of the same word need to be top level issues.
        /// </summary>
        [DataMember(Name = "locations", IsRequired = true)]
        public IList<Location> Locations { get; set; }

        /// <summary>
        /// A string that baselining mechanisms can merge with other data to help uniquely identify this issue, run-over-run.
        /// </summary>
        [DataMember(Name = "toolFingerprint", IsRequired = false, EmitDefaultValue = false)]
        public string ToolFingerprint { get; set; }

        /// <summary>
        /// A grouped set of locations, if available, that represent stacks associated with this result.
        /// </summary>
        [DataMember(Name = "stacks", IsRequired = false, EmitDefaultValue = false)]
        public IList<AnnotatedCodeLocation> Stacks { get; set; }

        /// <summary>
        /// A grouped set of location, if available, that comprise annotated
        /// execution flows through code which are associated with this result.
        /// </summary>
        [DataMember(Name = "executionFlows", IsRequired = false, EmitDefaultValue = false)]
        public IList<IList<AnnotatedCodeLocation>> ExecutionFlows { get; set; }

        /// <summary>
        /// A grouped set of locations and messages, if available, that represent code areas that are related
        /// to this result.
        /// </summary>
        [DataMember(Name = "relatedLocations", IsRequired = false, EmitDefaultValue = false)]
        public IList<AnnotatedCodeLocation> RelatedLocations { get; set; }

        /// <summary>
        /// A flag that indicates whether or not this result was suppressed in source code.
        /// </summary>
        [DataMember(Name = "isSuppressedInSource", IsRequired = false, EmitDefaultValue = false)]
        public bool IsSuppressedInSource { get; set; }

        /// <summary>
        /// An array of fix objects, if available, that can be applied in order to correct this result.
        /// </summary>
        [DataMember(Name = "fixes", IsRequired = false, EmitDefaultValue = false)]
        public IList<Fix> Fixes { get; set; }

        /// <summary>
        /// Key/value pairs that provide additional details about the result.
        /// </summary>
        [DataMember(Name = "properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

    }

    /// <summary>
    /// Static Analysis Results Format (SARIF) Version 1.0 JSON Schema (Draft 0.4). SARIF defines a standard format for the output of static analysis tools.
    /// </summary>
    public sealed class ResultLog
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.ResultLog.ToString(); } }

        /// <summary>
        /// The SARIF tool format version of this log file. This value should be set to 0.4, currently.
        /// This is the third proposed revision of a file format that is not yet completely finalized.
        /// </summary>
        [DataMember(Name = "version", IsRequired = true)]
        public string Version { get; set; }

        /// <summary>
        /// The set of runLogs contained in this SARIF log.
        /// </summary>
        [DataMember(Name = "runLogs", IsRequired = true)]
        public IList<RunLog> RunLogs { get; set; }
    }

    /// <summary>
    /// An object that contains information about an analysis rule.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class RuleDescriptor
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.RuleDescriptor.ToString(); } }

        /// <summary>
        /// A string that contains a stable, opaque identifier for a rule.
        /// </summary>
        [DataMember(Name = "id", IsRequired = true)]
        public string Id { get; set; }

        /// <summary>
        /// An optional string that contains a rule identifier that is understandable to an end user.
        /// </summary>
        [DataMember(Name = "name", IsRequired = false, EmitDefaultValue = false)]
        public string Name { get; set; }

        /// <summary>
        /// A string that contains a concise description of the rule. The short description property
        /// should be a single sentence that is understandable when displayed in user interface contexts
        /// where the available space is limited to a single line of text.
        /// </summary>
        [DataMember(Name = "shortDescription", IsRequired = false, EmitDefaultValue = false)]
        public string ShortDescription { get; set; }

        /// <summary>
        /// A string whose value is a string that describes the rule. The fullDescription property should,
        /// as far as possible, provide details sufficient to enable resolution of any problem indicated
        /// by the result.
        /// </summary>
        [DataMember(Name = "fullDescription", IsRequired = false, EmitDefaultValue = false)]
        public string FullDescription { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. The options
        /// objects shall describe the set of configurable options supported by the rule. The value
        /// within each name/value pair shall be a string, which may be the empty string. The value
        /// shall not be a dictionary or sub-object.
        /// </summary>
        [DataMember(Name = "options", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Options { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. The value
        /// within each name/value pair shall be a string that can be passed to a string formatting
        /// function (e.g., the C language printf function) to construct a formatted message in
        /// combination with an arbitrary number of additional function arguments.
        /// </summary>
        [DataMember(Name = "formatSpecifiers", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> FormatSpecifiers { get; set; }

        /// <summary>
        /// A URI where the primary documentation for the rule can be found.
        /// </summary>
        [DataMember(Name = "helpUri", IsRequired = false, EmitDefaultValue = false)]
        public string HelpUri { get; set; }

        /// <summary>
        /// A dictionary consisting of a set of name/value pairs with arbitrary names. This
        /// allows tools to include information about the rule that is not explicitly specified
        /// in the SARIF format. The value within each name/value pair shall be a string,
        /// which may be the empty string. The value shall not be a dictionary or sub-object.
        /// </summary>
        [DataMember(Name = "properties", IsRequired = false, EmitDefaultValue = false)]
        public global::System.Collections.Generic.Dictionary<string, string> Properties { get; set; }

    }

    /// <summary>
    /// A runInfo object describes the invocation of the static analysis tool that produced the results
    /// specified in the containing runLog object.
    /// NOTE: The information in the runInfo object makes it possible to precisely repeat a run of a
    /// static analysis tool, and to verify that the results reported in the log file were generated
    /// by an appropriate invocation of the tool.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class RunInfo
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.RunInfo.ToString(); } }

        /// <summary>
        /// A string that describes any parameterization for the tool invocation. For command line tools
        /// this string may consist of the completely specified command line used to invoke the tool.
        /// </summary>
        [DataMember(Name = "invocationInfo", IsRequired = false, EmitDefaultValue = false)]
        public string InvocationInfo { get; set; }

        /// <summary>
        /// An array, each of whose elements is a fileReference object representing the location of
        /// a single analysis target scanned during the run. When present, this array shall contain one entry
        /// fo reach analysis target that was scanned, even if the analysis targets were not individually specified
        /// on the command line.
        /// NOTE 1: The command line with which the tool was invoked might specify its input files by means
        /// of a wild card such as *.cc, or it might specify them implicitly, for example, by scanning the
        /// files in the current directory.
        /// The analysisTargets array shall be empty if no analysis targets were scanned in the course of the run.
        /// NOTE 2: This could happen if the command line specified a wildcard such as *.cc for the input files,
        /// and no files matched the wildcard.
        /// </summary>
        [DataMember(Name = "analysisTargets", IsRequired = false, EmitDefaultValue = false)]
        public IList<FileReference> AnalysisTargets { get; set; }

    }

    [DataContract]
    [CompilerGenerated]
    public sealed class RunLog
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.RunLog.ToString(); } }

        /// <summary>
        /// Information about the tool or tool pipeline that generated the results in this log. A results
        /// log can only contain results produced by a single tool or tool pipeline. A results log can
        /// aggregate results from multiple tool log files, as long as context around the tool run
        /// (tool command-line arguments and the like) is identical for all aggregated files.
        /// </summary>
        [DataMember(Name = "toolInfo", IsRequired = true)]
        public ToolInfo ToolInfo { get; set; }

        /// <summary>
        /// A runInfo object describes the invocation of the static analysis tool that produced the results
        /// specified in the containing runLog object.
        /// </summary>
        [DataMember(Name = "runInfo", IsRequired = false, EmitDefaultValue = false)]
        public RunInfo RunInfo { get; set; }

        /// <summary>
        /// An array of rule descriptor objects that describe all rules associated with an
        /// analysis tool or a specific run of an analysis tool.
        /// </summary>
        [DataMember(Name = "ruleInfo", IsRequired = false, EmitDefaultValue = false)]
        public IList<RuleDescriptor> RuleInfo { get; set; }

        /// <summary>
        /// The set of results contained in an SARIF log.
        /// </summary>
        [DataMember(Name = "results", IsRequired = false, EmitDefaultValue = false)]
        public IList<Result> Results { get; set; }

    }

    /// <summary>
    /// Information about the tool or tool pipeline that generated the results in this log.
    /// </summary>
    [DataContract]
    [CompilerGenerated]
    public sealed class ToolInfo
    {
        /// <summary>Gets the kind of type implementing <see cref="ISyntax" />.</summary>
        /// <value>The enumeration value for the kind of type implementing <see cref="ISyntax" />.</value>
        public string SyntaxKind { get { return SarifKind.ToolInfo.ToString(); } }

        /// <summary>
        /// The name of the tool or tool pipeline that generated the results in this log, e.g., FxCop.
        /// </summary>
        [DataMember(Name = "name", IsRequired = true)]
        public string Name { get; set; }

        /// <summary>
        /// The name of the tool along with its version and any other useful identifying information,
        /// such as its locale, e.g., 'CodeScanner 2.0, Developer Preview (en-US)'.
        /// </summary>
        [DataMember(Name = "fullName", IsRequired = false, EmitDefaultValue = false)]
        public string FullName { get; set; }

        /// <summary>
        /// A version that refers to the tool as a whole (as opposed to, for example,
        /// the build version of an individual binary in the tool).
        /// </summary>
        [DataMember(Name = "version", IsRequired = false, EmitDefaultValue = false)]
        public string Version { get; set; }

        /// <summary>
        /// For operating systems (such as Windows) that provide the data, the binary version
        /// of the primary tool exe.
        /// </summary>
        [DataMember(Name = "fileVersion", IsRequired = false, EmitDefaultValue = false)]
        public string FileVersion { get; set; }

    }
}
// End of generated code.

